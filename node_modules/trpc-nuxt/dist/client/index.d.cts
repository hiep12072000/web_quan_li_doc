import * as _trpc_client from '@trpc/client';
import { TRPCClientErrorLike, TRPCRequestOptions as TRPCRequestOptions$1, inferRouterProxyClient, CreateTRPCClientOptions } from '@trpc/client';
import { ProcedureRouterRecord, AnyRouter, AnyProcedure, AnyQueryProcedure, inferProcedureInput, AnyMutationProcedure, AnySubscriptionProcedure, ProcedureArgs, inferProcedureOutput } from '@trpc/server';
import { TRPCSubscriptionObserver } from '@trpc/client/dist/internals/TRPCUntypedClient';
import { inferObservableValue, Unsubscribable } from '@trpc/server/observable';
import { inferTransformedProcedureOutput } from '@trpc/server/shared';
import { KeysOf, AsyncDataOptions, AsyncData, PickFrom } from 'nuxt/dist/app/composables/asyncData';
import { Ref } from 'vue';
import { HTTPLinkOptions as HTTPLinkOptions$1 } from '@trpc/client/dist/links/httpLink';

interface TRPCRequestOptions extends TRPCRequestOptions$1 {
    abortOnUnmount?: boolean;
}
type Resolver<TProcedure extends AnyProcedure> = (...args: ProcedureArgs<TProcedure['_def']>) => Promise<inferTransformedProcedureOutput<TProcedure>>;
type SubscriptionResolver<TProcedure extends AnyProcedure, TRouter extends AnyRouter> = (...args: [
    input: ProcedureArgs<TProcedure['_def']>[0],
    opts: ProcedureArgs<TProcedure['_def']>[1] & Partial<TRPCSubscriptionObserver<inferObservableValue<inferProcedureOutput<TProcedure>>, TRPCClientErrorLike<TRouter>>>
]) => Unsubscribable;
type MaybeRef<T> = T | Ref<T>;
type DecorateProcedure<TProcedure extends AnyProcedure, TRouter extends AnyRouter> = TProcedure extends AnyQueryProcedure ? {
    useQuery: <ResT = inferTransformedProcedureOutput<TProcedure>, DataE = TRPCClientErrorLike<TProcedure>, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>>(input: MaybeRef<inferProcedureInput<TProcedure>>, opts?: AsyncDataOptions<ResT, DataT, PickKeys> & {
        trpc?: TRPCRequestOptions;
        /**
         * The custom unique key to use.
         * @see https://nuxt.com/docs/api/composables/use-async-data#params
         */
        queryKey?: string;
    }) => AsyncData<PickFrom<DataT, PickKeys> | null, DataE>;
    useLazyQuery: <ResT = inferTransformedProcedureOutput<TProcedure>, DataE = TRPCClientErrorLike<TProcedure>, DataT = ResT, PickKeys extends KeysOf<DataT> = KeysOf<DataT>>(input: MaybeRef<inferProcedureInput<TProcedure>>, opts?: Omit<AsyncDataOptions<ResT, DataT, PickKeys>, 'lazy'> & {
        trpc?: TRPCRequestOptions;
        /**
         * The custom unique key to use.
         * @see https://nuxt.com/docs/api/composables/use-async-data#params
         */
        queryKey?: string;
    }) => AsyncData<PickFrom<DataT, PickKeys> | null, DataE>;
    query: Resolver<TProcedure>;
} : TProcedure extends AnyMutationProcedure ? {
    mutate: Resolver<TProcedure>;
} : TProcedure extends AnySubscriptionProcedure ? {
    subscribe: SubscriptionResolver<TProcedure, TRouter>;
} : never;
/**
* @internal
*/
type DecoratedProcedureRecord<TProcedures extends ProcedureRouterRecord, TRouter extends AnyRouter> = {
    [TKey in keyof TProcedures]: TProcedures[TKey] extends AnyRouter ? DecoratedProcedureRecord<TProcedures[TKey]['_def']['record'], TRouter> : TProcedures[TKey] extends AnyProcedure ? DecorateProcedure<TProcedures[TKey], TRouter> : never;
};

interface HTTPLinkOptions extends HTTPLinkOptions$1 {
    /**
     * Select headers to pass to `useRequestHeaders`.
     */
    pickHeaders?: string[];
}
/**
 * This is a convenience wrapper around the original httpLink
 * that replaces regular `fetch` with a `$fetch` from Nuxt. It
 * also sets the default headers based on `useRequestHeaders` values.
 *
 * During server-side rendering, calling $fetch to fetch your internal API routes
 * will directly call the relevant function (emulating the request),
 * saving an additional API call.
 *
 * @see https://nuxt.com/docs/api/utils/dollarfetch
 */
declare function httpLink<TRouter extends AnyRouter>(opts?: HTTPLinkOptions): _trpc_client.TRPCLink<TRouter>;
interface HttpBatchLinkOptions extends HTTPLinkOptions {
    maxURLLength?: number;
}
/**
 * This is a convenience wrapper around the original httpBatchLink
 * that replaces regular `fetch` with a `$fetch` from Nuxt. It
 * also sets the default headers based on `useRequestHeaders` values.
 *
 * During server-side rendering, calling $fetch to fetch your internal API routes
 * will directly call the relevant function (emulating the request),
 * saving an additional API call.
 *
 * @see https://nuxt.com/docs/api/utils/dollarfetch
 */
declare function httpBatchLink<TRouter extends AnyRouter>(opts?: HttpBatchLinkOptions): _trpc_client.TRPCLink<TRouter>;

/**
 * Calculates the key used for `useAsyncData` call.
 *
 * @example
 *
 * ```ts
 * import { getQueryKey } from 'trpc-nuxt/client'
 *
 * $client.todo.getTodo(1)
 *
 * const queryKey = getQueryKey('todo.getTodo', 1)
 * ```
 */
declare function getQueryKey(path: string, input: unknown): string;
declare function createNuxtProxyDecoration<TRouter extends AnyRouter>(name: string, client: inferRouterProxyClient<TRouter>): unknown;
declare function createTRPCNuxtClient<TRouter extends AnyRouter>(opts: CreateTRPCClientOptions<TRouter>): DecoratedProcedureRecord<TRouter["_def"]["record"], TRouter>;

export { createNuxtProxyDecoration, createTRPCNuxtClient, getQueryKey, httpBatchLink, httpLink };
