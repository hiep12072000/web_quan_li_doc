"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_js_1 = require("../utils.js");
const header_object_js_1 = __importDefault(require("./header-object.js"));
const parameter_object_js_1 = __importDefault(require("./parameter-object.js"));
const path_item_object_js_1 = __importDefault(require("./path-item-object.js"));
const request_body_object_js_1 = __importDefault(require("./request-body-object.js"));
const response_object_js_1 = __importDefault(require("./response-object.js"));
const schema_object_map_js_1 = __importDefault(require("./schema-object-map.js"));
const schema_object_js_1 = __importDefault(require("./schema-object.js"));
function transformComponentsObject(components, ctx) {
    let { indentLv } = ctx;
    const output = ["{"];
    indentLv++;
    if (components.schemas) {
        const schemas = (0, schema_object_map_js_1.default)(components.schemas, { path: "#/components/schemas/", ctx: { ...ctx, indentLv } });
        output.push((0, utils_js_1.indent)(`schemas: ${schemas};`, indentLv));
    }
    else {
        output.push((0, utils_js_1.indent)("schemas: never;", indentLv));
    }
    if (components.responses) {
        output.push((0, utils_js_1.indent)("responses: {", indentLv));
        indentLv++;
        for (const [name, responseObject] of (0, utils_js_1.getEntries)(components.responses, ctx.alphabetize, ctx.excludeDeprecated)) {
            const c = (0, utils_js_1.getSchemaObjectComment)(responseObject, indentLv);
            if (c)
                output.push((0, utils_js_1.indent)(c, indentLv));
            let key = (0, utils_js_1.escObjKey)(name);
            if (ctx.immutableTypes)
                key = (0, utils_js_1.tsReadonly)(key);
            if ("$ref" in responseObject) {
                output.push((0, utils_js_1.indent)(`${key}": ${(0, schema_object_js_1.default)(responseObject, { path: `#/components/responses/${name}`, ctx })};`, indentLv));
            }
            else {
                const responseType = (0, response_object_js_1.default)(responseObject, {
                    path: `#/components/responses/${name}`,
                    ctx: { ...ctx, indentLv },
                });
                output.push((0, utils_js_1.indent)(`${key}: ${responseType};`, indentLv));
            }
        }
        indentLv--;
        output.push((0, utils_js_1.indent)("};", indentLv));
    }
    else {
        output.push((0, utils_js_1.indent)("responses: never;", indentLv));
    }
    if (components.parameters) {
        output.push((0, utils_js_1.indent)("parameters: {", indentLv));
        indentLv++;
        for (const [name, parameterObject] of (0, utils_js_1.getEntries)(components.parameters, ctx.alphabetize, ctx.excludeDeprecated)) {
            const c = (0, utils_js_1.getSchemaObjectComment)(parameterObject, indentLv);
            if (c)
                output.push((0, utils_js_1.indent)(c, indentLv));
            let key = (0, utils_js_1.escObjKey)(name);
            if (ctx.immutableTypes)
                key = (0, utils_js_1.tsReadonly)(key);
            if ("$ref" in parameterObject) {
                output.push((0, utils_js_1.indent)(`${key}: ${(0, schema_object_js_1.default)(parameterObject, { path: `#/components/parameters/${name}`, ctx })};`, indentLv));
            }
            else {
                if (parameterObject.in !== "path" && !parameterObject.required) {
                    key = (0, utils_js_1.tsOptionalProperty)(key);
                }
                const parameterType = (0, parameter_object_js_1.default)(parameterObject, {
                    path: `#/components/parameters/${name}`,
                    ctx: { ...ctx, indentLv },
                });
                output.push((0, utils_js_1.indent)(`${key}: ${parameterType};`, indentLv));
            }
        }
        indentLv--;
        output.push((0, utils_js_1.indent)("};", indentLv));
    }
    else {
        output.push((0, utils_js_1.indent)("parameters: never;", indentLv));
    }
    if (components.requestBodies) {
        output.push((0, utils_js_1.indent)("requestBodies: {", indentLv));
        indentLv++;
        for (const [name, requestBodyObject] of (0, utils_js_1.getEntries)(components.requestBodies, ctx.alphabetize, ctx.excludeDeprecated)) {
            const c = (0, utils_js_1.getSchemaObjectComment)(requestBodyObject, indentLv);
            if (c)
                output.push((0, utils_js_1.indent)(c, indentLv));
            let key = (0, utils_js_1.escObjKey)(name);
            if ("$ref" in requestBodyObject) {
                if (ctx.immutableTypes)
                    key = (0, utils_js_1.tsReadonly)(key);
                output.push((0, utils_js_1.indent)(`${key}: ${(0, schema_object_js_1.default)(requestBodyObject, {
                    path: `#/components/requestBodies/${name}`,
                    ctx: { ...ctx, indentLv },
                })};`, indentLv));
            }
            else {
                if (!requestBodyObject.required)
                    key = (0, utils_js_1.tsOptionalProperty)(key);
                if (ctx.immutableTypes)
                    key = (0, utils_js_1.tsReadonly)(key);
                const requestBodyType = (0, request_body_object_js_1.default)(requestBodyObject, {
                    path: `#/components/requestBodies/${name}`,
                    ctx: { ...ctx, indentLv },
                });
                output.push((0, utils_js_1.indent)(`${key}: ${requestBodyType};`, indentLv));
            }
        }
        indentLv--;
        output.push((0, utils_js_1.indent)("};", indentLv));
    }
    else {
        output.push((0, utils_js_1.indent)("requestBodies: never;", indentLv));
    }
    if (components.headers) {
        output.push((0, utils_js_1.indent)("headers: {", indentLv));
        indentLv++;
        for (const [name, headerObject] of (0, utils_js_1.getEntries)(components.headers, ctx.alphabetize, ctx.excludeDeprecated)) {
            const c = (0, utils_js_1.getSchemaObjectComment)(headerObject, indentLv);
            if (c)
                output.push((0, utils_js_1.indent)(c, indentLv));
            let key = (0, utils_js_1.escObjKey)(name);
            if (ctx.immutableTypes)
                key = (0, utils_js_1.tsReadonly)(key);
            if ("$ref" in headerObject) {
                output.push((0, utils_js_1.indent)(`${key}: ${(0, schema_object_js_1.default)(headerObject, { path: `#/components/headers/${name}`, ctx })};`, indentLv));
            }
            else {
                const headerType = (0, header_object_js_1.default)(headerObject, {
                    path: `#/components/headers/${name}`,
                    ctx: { ...ctx, indentLv },
                });
                output.push((0, utils_js_1.indent)(`${key}: ${headerType};`, indentLv));
            }
        }
        indentLv--;
        output.push((0, utils_js_1.indent)("};", indentLv));
    }
    else {
        output.push((0, utils_js_1.indent)("headers: never;", indentLv));
    }
    if (components.pathItems) {
        output.push((0, utils_js_1.indent)("pathItems: {", indentLv));
        indentLv++;
        for (const [name, pathItemObject] of (0, utils_js_1.getEntries)(components.pathItems, ctx.alphabetize, ctx.excludeDeprecated)) {
            let key = (0, utils_js_1.escObjKey)(name);
            if (ctx.immutableTypes)
                key = (0, utils_js_1.tsReadonly)(key);
            if ("$ref" in pathItemObject) {
                const c = (0, utils_js_1.getSchemaObjectComment)(pathItemObject, indentLv);
                if (c)
                    output.push((0, utils_js_1.indent)(c, indentLv));
                output.push((0, utils_js_1.indent)(`${key}: ${(0, schema_object_js_1.default)(pathItemObject, { path: `#/components/pathItems/${name}`, ctx })};`, indentLv));
            }
            else {
                output.push((0, utils_js_1.indent)(`${key}: ${(0, path_item_object_js_1.default)(pathItemObject, {
                    path: `#/components/pathItems/${name}`,
                    ctx: { ...ctx, indentLv },
                })};`, indentLv));
            }
        }
        indentLv--;
        output.push((0, utils_js_1.indent)("};", indentLv));
    }
    else {
        output.push((0, utils_js_1.indent)("pathItems: never;", indentLv));
    }
    indentLv--;
    output.push((0, utils_js_1.indent)("}", indentLv));
    return output.join("\n");
}
exports.default = transformComponentsObject;
//# sourceMappingURL=components-object.js.map