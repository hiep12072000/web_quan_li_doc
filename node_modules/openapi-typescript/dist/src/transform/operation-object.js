"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_js_1 = require("../utils.js");
const parameter_object_js_1 = __importDefault(require("./parameter-object.js"));
const request_body_object_js_1 = __importDefault(require("./request-body-object.js"));
const response_object_js_1 = __importDefault(require("./response-object.js"));
const schema_object_js_1 = __importDefault(require("./schema-object.js"));
function transformOperationObject(operationObject, { path, ctx, wrapObject = true }) {
    let { indentLv } = ctx;
    const output = wrapObject ? ["{"] : [];
    indentLv++;
    {
        if (operationObject.parameters) {
            const parameterOutput = [];
            indentLv++;
            for (const paramIn of ["query", "header", "path", "cookie"]) {
                const paramInternalOutput = [];
                indentLv++;
                let allOptional = true;
                for (const param of operationObject.parameters ?? []) {
                    const node = "$ref" in param ? ctx.parameters[param.$ref] : param;
                    if (node?.in !== paramIn)
                        continue;
                    let key = (0, utils_js_1.escObjKey)(node.name);
                    if (paramIn !== "path" && !node.required) {
                        key = (0, utils_js_1.tsOptionalProperty)(key);
                    }
                    else {
                        allOptional = false;
                    }
                    const c = (0, utils_js_1.getSchemaObjectComment)(param, indentLv);
                    if (c)
                        paramInternalOutput.push((0, utils_js_1.indent)(c, indentLv));
                    const parameterType = "$ref" in param
                        ? param.$ref
                        : (0, parameter_object_js_1.default)(param, {
                            path: `${path}/parameters/${param.name}`,
                            ctx: { ...ctx, indentLv },
                        });
                    paramInternalOutput.push((0, utils_js_1.indent)(`${key}: ${parameterType};`, indentLv));
                }
                indentLv--;
                if (paramInternalOutput.length) {
                    const key = allOptional ? (0, utils_js_1.tsOptionalProperty)(paramIn) : paramIn;
                    parameterOutput.push((0, utils_js_1.indent)(`${key}: {`, indentLv));
                    parameterOutput.push(...paramInternalOutput);
                    parameterOutput.push((0, utils_js_1.indent)(`};`, indentLv));
                }
            }
            indentLv--;
            if (parameterOutput.length) {
                output.push((0, utils_js_1.indent)(`parameters: {`, indentLv));
                output.push(parameterOutput.join("\n"));
                output.push((0, utils_js_1.indent)("};", indentLv));
            }
        }
    }
    {
        if (operationObject.requestBody) {
            const c = (0, utils_js_1.getSchemaObjectComment)(operationObject.requestBody, indentLv);
            if (c)
                output.push((0, utils_js_1.indent)(c, indentLv));
            let key = "requestBody";
            if (ctx.immutableTypes)
                key = (0, utils_js_1.tsReadonly)(key);
            if ("$ref" in operationObject.requestBody) {
                output.push((0, utils_js_1.indent)(`${key}: ${(0, schema_object_js_1.default)(operationObject.requestBody, { path, ctx })};`, indentLv));
            }
            else {
                if (!operationObject.requestBody.required)
                    key = (0, utils_js_1.tsOptionalProperty)(key);
                const requestBody = (0, request_body_object_js_1.default)(operationObject.requestBody, {
                    path: `${path}/requestBody`,
                    ctx: { ...ctx, indentLv },
                });
                output.push((0, utils_js_1.indent)(`${key}: ${requestBody};`, indentLv));
            }
        }
    }
    {
        if (operationObject.responses) {
            output.push((0, utils_js_1.indent)(`responses: {`, indentLv));
            indentLv++;
            for (const [responseCode, responseObject] of (0, utils_js_1.getEntries)(operationObject.responses, ctx.alphabetize, ctx.excludeDeprecated)) {
                const key = (0, utils_js_1.escObjKey)(responseCode);
                const c = (0, utils_js_1.getSchemaObjectComment)(responseObject, indentLv);
                if (c)
                    output.push((0, utils_js_1.indent)(c, indentLv));
                if ("$ref" in responseObject) {
                    output.push((0, utils_js_1.indent)(`${key}: ${(0, schema_object_js_1.default)(responseObject, {
                        path: `${path}/responses/${responseCode}`,
                        ctx,
                    })};`, indentLv));
                }
                else {
                    const responseType = (0, response_object_js_1.default)(responseObject, {
                        path: `${path}/responses/${responseCode}`,
                        ctx: { ...ctx, indentLv },
                    });
                    output.push((0, utils_js_1.indent)(`${key}: ${responseType};`, indentLv));
                }
            }
            indentLv--;
            output.push((0, utils_js_1.indent)(`};`, indentLv));
        }
    }
    indentLv--;
    if (wrapObject) {
        output.push((0, utils_js_1.indent)("}", indentLv));
    }
    return output.join("\n");
}
exports.default = transformOperationObject;
//# sourceMappingURL=operation-object.js.map