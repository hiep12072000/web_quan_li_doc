"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.COMMENT_HEADER = void 0;
const node_url_1 = require("node:url");
const load_js_1 = __importStar(require("./load.js"));
const index_js_1 = require("./transform/index.js");
const media_type_object_js_1 = __importDefault(require("./transform/media-type-object.js"));
const operation_object_js_1 = __importDefault(require("./transform/operation-object.js"));
const parameter_object_js_1 = __importDefault(require("./transform/parameter-object.js"));
const parameter_object_array_js_1 = __importDefault(require("./transform/parameter-object-array.js"));
const request_body_object_js_1 = __importDefault(require("./transform/request-body-object.js"));
const response_object_js_1 = __importDefault(require("./transform/response-object.js"));
const schema_object_js_1 = __importDefault(require("./transform/schema-object.js"));
const schema_object_map_js_1 = __importDefault(require("./transform/schema-object-map.js"));
const utils_js_1 = require("./utils.js");
__exportStar(require("./types.js"), exports);
const EMPTY_OBJECT_RE = /^\s*\{?\s*\}?\s*$/;
exports.COMMENT_HEADER = `/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

`;
async function openapiTS(schema, options = {}) {
    const ctx = {
        additionalProperties: options.additionalProperties ?? false,
        alphabetize: options.alphabetize ?? false,
        cwd: options.cwd ?? new node_url_1.URL(`file://${process.cwd()}/`),
        defaultNonNullable: options.defaultNonNullable ?? false,
        discriminators: {},
        transform: typeof options.transform === "function" ? options.transform : undefined,
        postTransform: typeof options.postTransform === "function" ? options.postTransform : undefined,
        immutableTypes: options.immutableTypes ?? false,
        emptyObjectsUnknown: options.emptyObjectsUnknown ?? false,
        indentLv: 0,
        operations: {},
        pathParamsAsTypes: options.pathParamsAsTypes ?? false,
        parameters: {},
        silent: options.silent ?? false,
        supportArrayLength: options.supportArrayLength ?? false,
        excludeDeprecated: options.excludeDeprecated ?? false,
    };
    const allSchemas = {};
    const schemaURL = typeof schema === "string" ? (0, load_js_1.resolveSchema)(schema) : schema;
    let rootURL = schemaURL;
    const isInlineSchema = typeof schema !== "string" && schema instanceof node_url_1.URL === false;
    if (isInlineSchema) {
        if (ctx.cwd) {
            if (ctx.cwd instanceof node_url_1.URL) {
                rootURL = ctx.cwd;
            }
            else if (typeof ctx.cwd === "string") {
                rootURL = new node_url_1.URL(ctx.cwd, `file://${process.cwd()}/`);
            }
            rootURL = new node_url_1.URL("root.yaml", rootURL);
        }
        else {
            rootURL = new node_url_1.URL(load_js_1.VIRTUAL_JSON_URL);
        }
    }
    await (0, load_js_1.default)(schemaURL, {
        ...ctx,
        auth: options.auth,
        schemas: allSchemas,
        rootURL,
        urlCache: new Set(),
        httpHeaders: options.httpHeaders,
        httpMethod: options.httpMethod,
        fetch: options.fetch ?? (0, utils_js_1.getDefaultFetch)(),
    });
    for (const k of Object.keys(allSchemas)) {
        const subschema = allSchemas[k];
        if (typeof subschema.schema.swagger === "string") {
            (0, utils_js_1.error)("Swagger 2.0 and older no longer supported. Please use v5.");
            process.exit(1);
        }
        if (subschema.hint === "OpenAPI3" && typeof subschema.schema.openapi === "string") {
            if (parseInt(subschema.schema.openapi) !== 3) {
                (0, utils_js_1.error)(`Unsupported OpenAPI version "${subschema.schema.openapi}". Only 3.x is supported.`);
                process.exit(1);
            }
        }
    }
    const output = [];
    if ("commentHeader" in options) {
        if (options.commentHeader)
            output.push(options.commentHeader);
    }
    else {
        output.push(exports.COMMENT_HEADER);
    }
    if (options.inject)
        output.push(options.inject);
    const rootTypes = (0, index_js_1.transformSchema)(allSchemas["."].schema, ctx);
    for (const k of Object.keys(rootTypes)) {
        if (rootTypes[k] && !EMPTY_OBJECT_RE.test(rootTypes[k])) {
            output.push(options.exportType ? `export type ${k} = ${rootTypes[k]};` : `export interface ${k} ${rootTypes[k]}`, "");
        }
        else {
            output.push(`export type ${k} = Record<string, never>;`, "");
        }
        delete rootTypes[k];
        delete allSchemas["."];
    }
    const externalKeys = Object.keys(allSchemas);
    if (externalKeys.length) {
        let indentLv = 0;
        output.push(options.exportType ? "export type external = {" : "export interface external {");
        externalKeys.sort((a, b) => a.localeCompare(b, "en", { numeric: true }));
        indentLv++;
        for (const subschemaID of externalKeys) {
            const subschema = allSchemas[subschemaID];
            const key = (0, utils_js_1.escObjKey)(subschemaID);
            const path = `${subschemaID}#`;
            let subschemaOutput = "";
            let comment;
            console.log({ subschemaID, hint: subschema.hint });
            switch (subschema.hint) {
                case "OpenAPI3": {
                    const subschemaTypes = (0, index_js_1.transformSchema)(subschema.schema, { ...ctx, indentLv: indentLv + 1 });
                    if (!Object.keys(subschemaTypes).length)
                        break;
                    output.push((0, utils_js_1.indent)(`${key}: {`, indentLv));
                    indentLv++;
                    for (const [k, v] of (0, utils_js_1.getEntries)(subschemaTypes, options.alphabetize, options.excludeDeprecated)) {
                        if (EMPTY_OBJECT_RE.test(v))
                            output.push((0, utils_js_1.indent)(`${(0, utils_js_1.escObjKey)(k)}: Record<string, never>;`, indentLv));
                        else
                            output.push((0, utils_js_1.indent)(`${(0, utils_js_1.escObjKey)(k)}: ${v};`, indentLv));
                    }
                    indentLv--;
                    output.push((0, utils_js_1.indent)("};", indentLv));
                    break;
                }
                case "MediaTypeObject": {
                    subschemaOutput = (0, media_type_object_js_1.default)(subschema.schema, { path, ctx: { ...ctx, indentLv } });
                    break;
                }
                case "OperationObject": {
                    comment = (0, utils_js_1.getSchemaObjectComment)(subschema.schema, indentLv);
                    subschemaOutput = (0, operation_object_js_1.default)(subschema.schema, { path, ctx: { ...ctx, indentLv } });
                    break;
                }
                case "ParameterObject": {
                    subschemaOutput = (0, parameter_object_js_1.default)(subschema.schema, { path, ctx: { ...ctx, indentLv } });
                    break;
                }
                case "ParameterObject[]": {
                    if (typeof subschema.schema === "object" && ("schema" in subschema.schema || "type" in subschema.schema)) {
                        subschemaOutput = (0, schema_object_js_1.default)(subschema.schema, { path, ctx: { ...ctx, indentLv } });
                    }
                    else {
                        subschemaOutput += "{\n";
                        indentLv++;
                        subschemaOutput += (0, parameter_object_array_js_1.default)(subschema.schema, { path, ctx: { ...ctx, indentLv } });
                        subschemaOutput += "\n";
                        indentLv--;
                        subschemaOutput += (0, utils_js_1.indent)("};", indentLv);
                    }
                    break;
                }
                case "RequestBodyObject": {
                    subschemaOutput = `${(0, request_body_object_js_1.default)(subschema.schema, { path, ctx: { ...ctx, indentLv } })};`;
                    break;
                }
                case "ResponseObject": {
                    subschemaOutput = `${(0, response_object_js_1.default)(subschema.schema, { path, ctx: { ...ctx, indentLv } })};`;
                    break;
                }
                case "SchemaMap": {
                    subschemaOutput = `${(0, schema_object_map_js_1.default)(subschema.schema, { path, ctx: { ...ctx, indentLv } })};`;
                    break;
                }
                case "SchemaObject": {
                    subschemaOutput = `${(0, schema_object_js_1.default)(subschema.schema, { path, ctx: { ...ctx, indentLv } })};`;
                    break;
                }
                default: {
                    (0, utils_js_1.error)(`Could not resolve subschema ${subschemaID}. Unknown type "${subschema.hint}".`);
                    process.exit(1);
                }
            }
            if (subschemaOutput && !EMPTY_OBJECT_RE.test(subschemaOutput)) {
                if (comment)
                    output.push((0, utils_js_1.indent)(comment, indentLv));
                output.push((0, utils_js_1.indent)(`${key}: ${subschemaOutput}`, indentLv));
            }
            delete allSchemas[subschemaID];
        }
        indentLv--;
        output.push((0, utils_js_1.indent)(`}${options.exportType ? ";" : ""}`, indentLv), "");
    }
    else {
        output.push(`export type external = Record<string, never>;`, "");
    }
    if (Object.keys(ctx.operations).length) {
        output.push(options.exportType ? "export type operations = {" : "export interface operations {", "");
        for (const [key, { operationType, comment }] of Object.entries(ctx.operations)) {
            if (comment)
                output.push((0, utils_js_1.indent)(comment, 1));
            output.push((0, utils_js_1.indent)(`${(0, utils_js_1.escObjKey)(key)}: ${operationType};`, 1));
        }
        output.push(`}${options.exportType ? ";" : ""}`, "");
    }
    else {
        output.push(`export type operations = Record<string, never>;`, "");
    }
    if (output.join("\n").includes("OneOf")) {
        output.splice(1, 0, "/** OneOf type helpers */", "type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };", "type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;", "type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;", "");
    }
    if (output.join("\n").includes("WithRequired")) {
        output.splice(1, 0, "/** WithRequired type helpers */", "type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };", "");
    }
    return output.join("\n");
}
exports.default = openapiTS;
//# sourceMappingURL=index.js.map