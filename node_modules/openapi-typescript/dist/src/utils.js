"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultFetch = exports.isFilepath = exports.isRemoteURL = exports.error = exports.getEntries = exports.indent = exports.escObjKey = exports.escStr = exports.tsUnionOf = exports.tsTupleOf = exports.tsReadonly = exports.tsOptionalProperty = exports.tsWithRequired = exports.tsOmit = exports.tsPick = exports.tsOneOf = exports.tsNonNullable = exports.tsIntersectionOf = exports.tsArrayOf = exports.encodeRef = exports.decodeRef = exports.makeTSIndex = exports.parseTSIndex = exports.parseRef = exports.comment = exports.getSchemaObjectComment = exports.walk = exports.TS_INDEX_RE = exports.DOUBLE_QUOTE_RE = exports.LB_RE = exports.c = void 0;
const ansi_colors_1 = __importDefault(require("ansi-colors"));
exports.c = ansi_colors_1.default;
const node_path_1 = require("node:path");
const supports_color_1 = __importDefault(require("supports-color"));
const undici_1 = require("undici");
if (!supports_color_1.default.stdout || supports_color_1.default.stdout.hasBasic === false)
    ansi_colors_1.default.enabled = false;
const COMMENT_RE = /\*\//g;
exports.LB_RE = /\r?\n/g;
exports.DOUBLE_QUOTE_RE = /(?<!\\)"/g;
const ESC_0_RE = /~0/g;
const ESC_1_RE = /~1/g;
const TILDE_RE = /~/g;
const FS_RE = /\//g;
exports.TS_INDEX_RE = /\[("(\\"|[^"])+"|'(\\'|[^'])+')]/g;
const TS_UNION_INTERSECTION_RE = /[&|]/;
const JS_OBJ_KEY = /^(\d+|[A-Za-z_$][A-Za-z0-9_$]*)$/;
function walk(obj, cb, path = []) {
    if (!obj || typeof obj !== "object")
        return;
    if (Array.isArray(obj)) {
        for (let i = 0; i < obj.length; i++)
            walk(obj[i], cb, path.concat(i));
        return;
    }
    cb(obj, path);
    for (const k of Object.keys(obj))
        walk(obj[k], cb, path.concat(k));
}
exports.walk = walk;
function getSchemaObjectComment(v, indentLv) {
    if (!v || typeof v !== "object")
        return;
    const output = [];
    if (v.title)
        output.push(v.title);
    if (v.summary)
        output.push(v.summary);
    if (v.format)
        output.push(`Format: ${v.format}`);
    if (v.deprecated)
        output.push("@deprecated");
    const supportedJsDocTags = ["description", "default", "example"];
    for (const field of supportedJsDocTags) {
        const allowEmptyString = field === "default" || field === "example";
        if (v[field] === undefined) {
            continue;
        }
        if (v[field] === "" && !allowEmptyString) {
            continue;
        }
        const serialized = typeof v[field] === "object" ? JSON.stringify(v[field], null, 2) : v[field];
        output.push(`@${field} ${serialized}`);
    }
    if ("const" in v)
        output.push("@constant");
    if (v.enum) {
        let type = "unknown";
        if (Array.isArray(v.type))
            type = v.type.join("|");
        else if (typeof v.type === "string")
            type = v.type;
        output.push(`@enum {${type}${v.nullable ? `|null` : ""}}`);
    }
    return output.length ? comment(output.join("\n"), indentLv) : undefined;
}
exports.getSchemaObjectComment = getSchemaObjectComment;
function comment(text, indentLv) {
    const commentText = text.trim().replace(COMMENT_RE, "*\\/");
    if (!commentText.includes("\n"))
        return `/** ${commentText} */`;
    const star = indent(" *", indentLv ?? 0);
    const body = commentText.split(exports.LB_RE).map((ln) => {
        ln = ln.trimEnd();
        return ln.length > 0 ? `${star} ${ln}` : star;
    });
    return ["/**", body.join("\n"), indent(" */", indentLv ?? 0)].join("\n");
}
exports.comment = comment;
function parseRef(ref) {
    if (typeof ref !== "string")
        return { filename: ".", path: [] };
    if (ref.includes("#/")) {
        const [filename, pathStr] = ref.split("#");
        const parts = pathStr.split("/");
        const path = [];
        for (const part of parts) {
            if (!part || part === "properties")
                continue;
            path.push(decodeRef(part));
        }
        return { filename: filename || ".", path };
    }
    else if (ref.includes('["')) {
        const parts = ref.split('["');
        const path = [];
        for (const part of parts) {
            const sanitized = part.replace('"]', "").trim();
            if (!sanitized || sanitized === "properties")
                continue;
            path.push(sanitized);
        }
        return { filename: ".", path };
    }
    return { filename: ref, path: [] };
}
exports.parseRef = parseRef;
function parseTSIndex(type) {
    const parts = [];
    const bracketI = type.indexOf("[");
    if (bracketI === -1)
        return [type];
    parts.push(type.substring(0, bracketI));
    const matches = type.match(exports.TS_INDEX_RE);
    if (matches) {
        for (const m of matches)
            parts.push(m.substring('["'.length, m.length - '"]'.length));
    }
    return parts;
}
exports.parseTSIndex = parseTSIndex;
function makeTSIndex(parts) {
    return `${parts[0]}[${parts.slice(1).map(escStr).join("][")}]`;
}
exports.makeTSIndex = makeTSIndex;
function decodeRef(ref) {
    return ref.replace(ESC_0_RE, "~").replace(ESC_1_RE, "/").replace(exports.DOUBLE_QUOTE_RE, '\\"');
}
exports.decodeRef = decodeRef;
function encodeRef(ref) {
    return ref.replace(TILDE_RE, "~0").replace(FS_RE, "~1");
}
exports.encodeRef = encodeRef;
function parenthesise(type) {
    return TS_UNION_INTERSECTION_RE.test(type) ? `(${type})` : type;
}
function tsArrayOf(type) {
    return `${parenthesise(type)}[]`;
}
exports.tsArrayOf = tsArrayOf;
function tsIntersectionOf(...types) {
    types = types.filter((t) => t !== "unknown");
    if (types.length === 0)
        return "unknown";
    if (types.length === 1)
        return String(types[0]);
    return types.map((t) => parenthesise(t)).join(" & ");
}
exports.tsIntersectionOf = tsIntersectionOf;
function tsNonNullable(type) {
    return `NonNullable<${type}>`;
}
exports.tsNonNullable = tsNonNullable;
function tsOneOf(...types) {
    if (types.length === 1) {
        return types[0];
    }
    else if (types.length > 5) {
        return tsUnionOf(...types);
    }
    return `OneOf<[${types.join(", ")}]>`;
}
exports.tsOneOf = tsOneOf;
function tsPick(root, keys) {
    return `Pick<${root}, ${tsUnionOf(...keys.map(escStr))}>`;
}
exports.tsPick = tsPick;
function tsOmit(root, keys) {
    return `Omit<${root}, ${tsUnionOf(...keys.map(escStr))}>`;
}
exports.tsOmit = tsOmit;
function tsWithRequired(root, keys) {
    return `WithRequired<${root}, ${tsUnionOf(...keys.map(escStr))}>`;
}
exports.tsWithRequired = tsWithRequired;
function tsOptionalProperty(key) {
    return `${key}?`;
}
exports.tsOptionalProperty = tsOptionalProperty;
function tsReadonly(type) {
    return `readonly ${type}`;
}
exports.tsReadonly = tsReadonly;
function tsTupleOf(...types) {
    return `[${types.join(", ")}]`;
}
exports.tsTupleOf = tsTupleOf;
function tsUnionOf(...types) {
    if (types.length === 0)
        return "never";
    const members = new Set();
    for (const t of types) {
        if (t === "unknown")
            return "unknown";
        members.add(String(t));
    }
    if (members.has("never") && members.size === 1)
        return "never";
    members.delete("never");
    const memberArr = Array.from(members);
    if (members.size === 1)
        return memberArr[0];
    let out = "";
    for (let i = 0; i < memberArr.length; i++) {
        const t = memberArr[i];
        out += parenthesise(t);
        if (i !== memberArr.length - 1)
            out += " | ";
    }
    return out;
}
exports.tsUnionOf = tsUnionOf;
function escStr(input) {
    if (typeof input !== "string")
        return JSON.stringify(input);
    return `"${input.replace(exports.LB_RE, "").replace(exports.DOUBLE_QUOTE_RE, '\\"')}"`;
}
exports.escStr = escStr;
function escObjKey(input) {
    return JS_OBJ_KEY.test(input) ? input : escStr(input);
}
exports.escObjKey = escObjKey;
function indent(input, level) {
    if (level > 0) {
        return "  ".repeat(level).concat(input);
    }
    else {
        return input;
    }
}
exports.indent = indent;
function getEntries(obj, alphabetize, excludeDeprecated) {
    let entries = Object.entries(obj);
    if (alphabetize)
        entries.sort(([a], [b]) => a.localeCompare(b, "en", { numeric: true }));
    if (excludeDeprecated)
        entries = entries.filter(([, v]) => !(v && typeof v === "object" && "deprecated" in v && v.deprecated));
    return entries;
}
exports.getEntries = getEntries;
function error(msg) {
    console.error(ansi_colors_1.default.red(` âœ˜  ${msg}`));
}
exports.error = error;
function isRemoteURL(url) {
    return url.startsWith("https://") || url.startsWith("//") || url.startsWith("http://");
}
exports.isRemoteURL = isRemoteURL;
function isFilepath(url) {
    return url.startsWith("file://") || (0, node_path_1.isAbsolute)(url);
}
exports.isFilepath = isFilepath;
function getDefaultFetch() {
    const globalFetch = globalThis.fetch;
    if (typeof globalFetch === "undefined") {
        return undici_1.fetch;
    }
    return globalFetch;
}
exports.getDefaultFetch = getDefaultFetch;
//# sourceMappingURL=utils.js.map